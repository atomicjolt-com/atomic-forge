use crate::errors::{ClientCredentialsError, SecureError};
use crate::jwt::encode;
use crate::secure::generate_secure_string;
use cached::proc_macro::cached;
use cached::TimedSizedCache;
use chrono::{Duration, Utc};
use openssl::rsa::Rsa;
use reqwest::header;
use serde::{Deserialize, Serialize};
use tokio::time::sleep;

const AUTHORIZATION_TRIES: u8 = 3;

// https://www.imsglobal.org/spec/lti/v1p3/#token-endpoint-claim-and-services
// When requesting an access token, the client assertion JWT iss and sub must both be the
// OAuth 2 client_id of the tool as issued by the learning platform during registration.
// Additional information:
// https://www.imsglobal.org/spec/security/v1p0/#using-json-web-tokens-with-oauth-2-0-client-credentials-grant
//
// Example usage:
// ```
// let credentials = ClientCredentials::new(client_id, platform_token_url);
// let token = credentials.build_signed_token(rsa_key_pair)?;
// ```
#[derive(Debug, Deserialize, Serialize)]
pub struct ClientCredentials {
  iss: String,      // A unique identifier for the entity that issued the JWT
  sub: String,      // "client_id" of the OAuth Client
  aud: Vec<String>, // Authorization server identifier. Usually the token endpoint URL of the authorization server
  iat: i64,         // Timestamp for when the JWT was created
  exp: i64, // Timestamp for when the JWT should be treated as having expired (after allowing a margin for clock skew)
  jti: String, // A unique (potentially reusable) identifier for the token
}

impl ClientCredentials {
  // client_id -The LTI tool's client_id as provided by the platform
  // aud - Authorization server identifier. Usually the token endpoint URL of the authorization server
  pub fn new(client_id: &str, aud: &str) -> Self {
    Self {
      iss: client_id.to_string(),
      sub: client_id.to_string(),
      aud: vec![aud.to_string()],
      iat: Utc::now().timestamp(),
      exp: (Utc::now() + Duration::minutes(300)).timestamp(),
      jti: generate_secure_string(10),
    }
  }

  // Generate a signed JWT token using the provided RSA key pair
  pub fn build_signed_token(
    &self,
    kid: &str,
    rsa_key_pair: Rsa<openssl::pkey::Private>,
  ) -> Result<String, SecureError> {
    encode(self, kid, rsa_key_pair)
  }
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct ClientAuthorizationRequest {
  grant_type: &'static str,
  client_assertion_type: &'static str,
  scope: String,
  client_assertion: String,
}

impl ClientAuthorizationRequest {
  const GRANT_TYPE: &'static str = "client_credentials";
  const CLIENT_ASSERTION_TYPE: &'static str =
    "urn:ietf:params:oauth:client-assertion-type:jwt-bearer";

  // Build a new ClientAuthorizationRequest.
  // scopes - a list of scopes to request access to each separated by a space. For example:
  //   "https://purl.imsglobal.org/spec/lti-ags/scope/lineitem https://purl.imsglobal.org/spec/lti-ags/scope/result/read"
  // client_assertion - a signed JWT token generated by the ClientCredentials struct
  fn new(scopes: &str, client_assertion: &str) -> Self {
    Self {
      grant_type: Self::GRANT_TYPE,
      client_assertion_type: Self::CLIENT_ASSERTION_TYPE,
      scope: scopes.to_string(),
      client_assertion: client_assertion.to_string(),
    }
  }
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct ClientAuthorizationResponse {
  pub access_token: String,
  pub token_type: String,
  pub expires_in: i64,
  pub scope: String,
}

// Request a service token capable of making LTI 1.3 service calls to the LMS.
// This function will cache the resulting token for 15 minutes.
//
// Arguments:
// client_id - The LTI tool's client_id as provided by the platform
// platform_token_url - The platform's token endpoint URL
// scopes - a list of scopes to request access to each separated by a space. For example:
//   "https://purl.imsglobal.org/spec/lti-ags/scope/lineitem https://purl.imsglobal.org/spec/lti-ags/scope/result/read"
// rsa_key_pair - The RSA key pair used to sign the JWT token
#[cached(
  result = true, // Only "Ok" results are cached
  sync_writes = true, // When called concurrently, duplicate argument-calls will be synchronized so as to only run once
  create = "{ TimedSizedCache::with_size_and_lifespan(100, 900) }", // 15 mins
  type = "TimedSizedCache<String, ClientAuthorizationResponse>",
  convert = r#"{ format!("{}{:?}", client_id, scopes) }"#,
)]
pub async fn request_service_token_cached(
  client_id: &str,
  platform_token_url: &str,
  scopes: &str,
  kid: &str,
  rsa_key_pair: Rsa<openssl::pkey::Private>,
) -> Result<ClientAuthorizationResponse, ClientCredentialsError> {
  let mut count = 0;
  let credentials = ClientCredentials::new(client_id, platform_token_url);
  let token = credentials
    .build_signed_token(kid, rsa_key_pair)
    .map_err(|e| ClientCredentialsError::RequestFailed(e.to_string()))?;
  let mut last_error = String::new();
  while count < AUTHORIZATION_TRIES {
    match request_service_token(platform_token_url, &token, scopes).await {
      Ok(response) => return Ok(response),
      Err(ClientCredentialsError::RateLimited(e)) => {
        last_error = e.to_string();
        // Wait 1 second before trying again
        sleep(std::time::Duration::from_secs(1)).await;
      }
      Err(e) => return Err(e),
    }
    count += 1;
  }
  Err(ClientCredentialsError::RequestLimitReached(last_error))
}

pub async fn request_service_token(
  platform_token_url: &str,
  token: &str,
  scopes: &str,
) -> Result<ClientAuthorizationResponse, ClientCredentialsError> {
  let params = ClientAuthorizationRequest::new(scopes, token);
  let client = reqwest::Client::new();
  let response = client
    .post(platform_token_url)
    .header(header::CONTENT_TYPE, "application/x-www-form-urlencoded")
    .form(&params)
    .send()
    .await
    .map_err(|e| ClientCredentialsError::RequestFailed(e.to_string()))?;
  let status = response.status();
  let body = response
    .text()
    .await
    .map_err(|e| ClientCredentialsError::RequestFailed(e.to_string()))?;
  if !status.is_success() {
    if body.contains("rate limit") {
      return Err(ClientCredentialsError::RateLimited(body));
    }

    return Err(ClientCredentialsError::RequestFailed(body));
  }

  let access_token_response: ClientAuthorizationResponse = serde_json::from_str(&body)
    .map_err(|e| ClientCredentialsError::RequestFailed(e.to_string()))?;

  Ok(access_token_response)
}

#[cfg(test)]
mod tests {
  use super::*;
  use openssl::rsa::Rsa;

  #[tokio::test]
  async fn test_request_service_token_success() {
    let mut server = mockito::Server::new();
    let server_url = server.url();
    let response = ClientAuthorizationResponse {
      access_token: "fake".to_string(),
      token_type: "Bearer".to_string(),
      expires_in: 3600,
      scope: "https://purl.imsglobal.org/spec/lti-ags/scope/lineitem https://purl.imsglobal.org/spec/lti-ags/scope/result/read".to_string(),
    };
    let response_body = serde_json::to_string(&response).expect("failed to serialize response");
    let mock = server
      .mock("POST", "/token")
      .with_status(200)
      .with_body(response_body)
      .create();
    let client_id = "test_client_id";
    let platform_token_url = format!("{}/token", server_url);
    let rsa = Rsa::generate(2048).expect("failed to generate rsa key pair");
    let kid = "test_kid";
    let scopes = "https://purl.imsglobal.org/spec/lti-ags/scope/lineitem https://purl.imsglobal.org/spec/lti-ags/scope/result/read";
    let result =
      request_service_token_cached(client_id, &platform_token_url, scopes, kid, rsa).await;
    mock.assert();
    assert!(result.is_ok());
  }

  #[tokio::test]
  async fn test_request_service_token_rate_limited() {
    let mut server = mockito::Server::new();
    let server_url = server.url();
    let mock = server
      .mock("POST", "/token")
      .with_status(429)
      .with_body("rate limit exceeded")
      .expect(3) // Mock should be called 3 times
      .create();
    let client_id = "test_fail_client_id";
    let platform_token_url = format!("{}/token", server_url);
    let rsa = Rsa::generate(2048).expect("failed to generate rsa key pair");
    let scopes = "https://purl.imsglobal.org/spec/lti-ags/scope/lineitem https://purl.imsglobal.org/spec/lti-ags/scope/result/read";
    let kid = "test_kid";
    let result =
      request_service_token_cached(client_id, &platform_token_url, scopes, kid, rsa).await;

    mock.assert();
    assert!(matches!(
      result,
      Err(ClientCredentialsError::RequestLimitReached(_))
    ));
  }
}
