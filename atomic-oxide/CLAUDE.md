# CLAUDE.md - atomic-oxide

This file provides guidance to Claude Code (claude.ai/code) when working with the atomic-oxide project.

## Project Overview

Atomic Oxide is an LTI (Learning Tools Interoperability) Tool implementation using Rust and Diesel ORM. It demonstrates the same LTI improvements as atomic-decay but using Diesel instead of SQLx.

## Key Differences from atomic-decay

| Feature | atomic-decay | atomic-oxide |
|---------|-------------|--------------|
| ORM | SQLx (compile-time checked) | Diesel (query builder) |
| Query Style | SQL macros | Type-safe query builder |
| Async | Native async with sqlx | Sync queries with async wrappers |
| Migrations | SQLx CLI | Diesel CLI |
| Schema | Runtime | Compile-time (schema.rs) |

## Development Commands

### Building and Running

```bash
# Set PostgreSQL library path (required for macOS)
export PQ_LIB_DIR="$(brew --prefix libpq)/lib"

# Build the project
cargo build

# Run the application
cargo run

# Run with auto-reload during development
systemfd --no-pid -s http::$PORT -- cargo watch -x run
```

### Database Operations with Diesel

```bash
# Install Diesel CLI
cargo install diesel_cli --no-default-features --features postgres

# Setup database (creates database and runs migrations)
diesel setup

# Create a new migration
diesel migration generate <migration_name>

# Run migrations
diesel migration run

# Revert last migration
diesel migration revert

# Regenerate schema.rs (after migrations)
diesel migration run
```

### Testing

```bash
# Run all tests
cargo test

# Run with output
cargo test -- --nocapture

# Run specific test
cargo test <test_name>

# Single-threaded (useful for database tests)
cargo test -- --test-threads=1
```

### Linting and Formatting

```bash
# Format code
cargo fmt

# Check formatting
cargo fmt -- --check

# Run clippy
cargo clippy -- -D warnings
```

## Architecture Overview

### Diesel-Specific Patterns

#### 1. Schema Definition

The `schema.rs` file is auto-generated by Diesel and defines the database schema at compile-time:

```rust
// src/schema.rs (auto-generated, do not edit manually)
diesel::table! {
    lti_platforms (id) {
        id -> Int4,
        issuer -> Text,
        name -> Nullable<Text>,
        jwks_url -> Text,
        token_url -> Text,
        oidc_url -> Text,
        created_at -> Timestamp,
        updated_at -> Timestamp,
    }
}

diesel::table! {
    lti_registrations (id) {
        id -> Int4,
        platform_id -> Int4,
        client_id -> Text,
        deployment_id -> Nullable<Text>,
        registration_config -> Jsonb,  // JSONB support
        registration_token -> Nullable<Text>,
        status -> Text,
        supported_placements -> Nullable<Jsonb>,
        supported_message_types -> Nullable<Jsonb>,
        capabilities -> Nullable<Jsonb>,
        created_at -> Timestamp,
        updated_at -> Timestamp,
    }
}

diesel::joinable!(lti_registrations -> lti_platforms (platform_id));
diesel::allow_tables_to_appear_in_same_query!(lti_platforms, lti_registrations);
```

#### 2. Model Definitions

Diesel uses separate structs for querying vs inserting:

```rust
use diesel::prelude::*;
use serde::{Deserialize, Serialize};

// For SELECT queries
#[derive(Queryable, Selectable, Debug, Clone, Serialize, Deserialize)]
#[diesel(table_name = crate::schema::lti_platforms)]
pub struct LtiPlatform {
    pub id: i32,
    pub issuer: String,
    pub name: Option<String>,
    pub jwks_url: String,
    pub token_url: String,
    pub oidc_url: String,
    pub created_at: chrono::NaiveDateTime,
    pub updated_at: chrono::NaiveDateTime,
}

// For INSERT queries
#[derive(Insertable, Debug, Clone)]
#[diesel(table_name = crate::schema::lti_platforms)]
pub struct NewLtiPlatform {
    pub issuer: String,
    pub name: Option<String>,
    pub jwks_url: String,
    pub token_url: String,
    pub oidc_url: String,
}
```

#### 3. JSONB Handling

Diesel supports JSONB with custom types:

```rust
use serde_json::Value as JsonValue;

// In model
#[derive(Queryable, Selectable)]
pub struct LtiRegistration {
    pub id: i32,
    pub registration_config: JsonValue,  // Diesel handles JSONB
    pub supported_placements: Option<JsonValue>,
    pub supported_message_types: Option<JsonValue>,
    pub capabilities: Option<JsonValue>,
}

// In queries
use crate::schema::lti_registrations::dsl::*;

let registration = lti_registrations
    .filter(client_id.eq("abc123"))
    .select(LtiRegistration::as_select())
    .first(&mut conn)?;

// Access JSONB data
if let Some(placements) = &registration.supported_placements {
    println!("Placements: {}", placements);
}
```

#### 4. Query Builder Pattern

```rust
use diesel::prelude::*;
use crate::schema::lti_platforms::dsl::*;

// Simple query
let platforms = lti_platforms
    .load::<LtiPlatform>(&mut conn)?;

// Filtered query
let platform = lti_platforms
    .filter(issuer.eq("https://canvas.instructure.com"))
    .first::<LtiPlatform>(&mut conn)?;

// Insert
let new_platform = NewLtiPlatform {
    issuer: "https://canvas.instructure.com".to_string(),
    name: Some("Canvas LMS".to_string()),
    jwks_url: "https://canvas.instructure.com/api/lti/security/jwks".to_string(),
    token_url: "https://canvas.instructure.com/login/oauth2/token".to_string(),
    oidc_url: "https://canvas.instructure.com/api/lti/authorize_redirect".to_string(),
};

diesel::insert_into(lti_platforms)
    .values(&new_platform)
    .get_result::<LtiPlatform>(&mut conn)?;

// Update
diesel::update(lti_platforms.filter(issuer.eq("https://canvas.instructure.com")))
    .set(name.eq("Updated Canvas LMS"))
    .execute(&mut conn)?;

// Delete
diesel::delete(lti_platforms.filter(issuer.eq("https://canvas.instructure.com")))
    .execute(&mut conn)?;
```

#### 5. Async Wrapper

Diesel is synchronous, so we wrap calls for async contexts:

```rust
use tokio::task;

pub async fn find_platform_async(pool: &PgPool, iss: &str) -> Result<Option<LtiPlatform>, Error> {
    let iss = iss.to_string();
    let mut conn = pool.get()?;

    // Run Diesel query in blocking thread pool
    task::spawn_blocking(move || {
        use crate::schema::lti_platforms::dsl::*;

        lti_platforms
            .filter(issuer.eq(&iss))
            .first::<LtiPlatform>(&mut conn)
            .optional()
    })
    .await?
}
```

### Store Implementations

#### DBPlatformStore

```rust
use atomic_lti::stores::platform_store::{PlatformStore, PlatformData};
use diesel::prelude::*;

pub struct DBPlatformStore {
    pool: PgPool,
    iss: String,
}

#[async_trait]
impl PlatformStore for DBPlatformStore {
    async fn get_oidc_url(&self) -> Result<String, PlatformError> {
        let iss = self.iss.clone();
        let mut conn = self.pool.get()?;

        task::spawn_blocking(move || {
            use crate::schema::lti_platforms::dsl::*;

            let platform = lti_platforms
                .filter(issuer.eq(&iss))
                .first::<LtiPlatform>(&mut conn)?;

            Ok(platform.oidc_url)
        })
        .await?
    }

    async fn create(&self, platform: PlatformData) -> Result<PlatformData, PlatformError> {
        let mut conn = self.pool.get()?;

        task::spawn_blocking(move || {
            use crate::schema::lti_platforms;

            let new_platform = NewLtiPlatform {
                issuer: platform.issuer.clone(),
                name: platform.name.clone(),
                jwks_url: platform.jwks_url.clone(),
                token_url: platform.token_url.clone(),
                oidc_url: platform.oidc_url.clone(),
            };

            diesel::insert_into(lti_platforms::table)
                .values(&new_platform)
                .execute(&mut conn)?;

            Ok(platform)
        })
        .await?
    }

    // Implement other methods...
}
```

#### DBRegistrationStore (with JSONB)

```rust
use atomic_lti::stores::registration_store::{RegistrationStore, RegistrationData};

pub struct DBRegistrationStore {
    pool: PgPool,
}

#[async_trait]
impl RegistrationStore for DBRegistrationStore {
    async fn find_by_client_id(&self, client: &str) -> Result<Option<RegistrationData>, RegistrationError> {
        let client = client.to_string();
        let mut conn = self.pool.get()?;

        task::spawn_blocking(move || {
            use crate::schema::lti_registrations::dsl::*;

            let reg = lti_registrations
                .filter(client_id.eq(&client))
                .first::<LtiRegistration>(&mut conn)
                .optional()?;

            Ok(reg.map(|r| RegistrationData {
                platform_id: r.platform_id,
                client_id: r.client_id,
                deployment_id: r.deployment_id,
                registration_config: r.registration_config,
                registration_token: r.registration_token,
                status: r.status,
                supported_placements: r.supported_placements,
                supported_message_types: r.supported_message_types,
                capabilities: r.capabilities,
            }))
        })
        .await?
    }

    // Implement other methods...
}
```

### Migration Workflow

#### Creating Migrations

```bash
# Generate migration files
diesel migration generate add_issuer_to_oidc_states

# This creates:
# migrations/TIMESTAMP_add_issuer_to_oidc_states/
#   ├── up.sql
#   └── down.sql
```

#### Writing Migrations

```sql
-- up.sql
ALTER TABLE oidc_states ADD COLUMN issuer TEXT;

-- down.sql
ALTER TABLE oidc_states DROP COLUMN issuer;
```

#### Running Migrations

```bash
# Run all pending migrations
diesel migration run

# This automatically:
# 1. Runs the SQL in up.sql
# 2. Regenerates schema.rs
# 3. Updates migration tracking table

# Revert last migration
diesel migration revert

# Redo (revert + run)
diesel migration redo
```

### Environment Configuration

Required environment variables:

```bash
# Database URL for Diesel
DATABASE_URL=postgresql://user:password@localhost/atomic_oxide_dev

# PostgreSQL library path (macOS)
PQ_LIB_DIR=$(brew --prefix libpq)/lib
```

Diesel configuration (`diesel.toml`):

```toml
[print_schema]
file = "src/schema.rs"
```

### Testing with Diesel

```rust
use diesel::prelude::*;
use diesel::r2d2::{self, ConnectionManager};

#[cfg(test)]
mod tests {
    use super::*;

    fn setup_test_db() -> PgPool {
        let database_url = std::env::var("DATABASE_URL")
            .expect("DATABASE_URL must be set for tests");

        let manager = ConnectionManager::<PgConnection>::new(&database_url);
        r2d2::Pool::builder()
            .build(manager)
            .expect("Failed to create pool")
    }

    #[tokio::test]
    async fn test_create_platform() {
        let pool = setup_test_db();

        let platform_data = PlatformData {
            issuer: "https://test.example.com".to_string(),
            name: Some("Test Platform".to_string()),
            jwks_url: "https://test.example.com/jwks".to_string(),
            token_url: "https://test.example.com/token".to_string(),
            oidc_url: "https://test.example.com/oidc".to_string(),
        };

        let store = DBPlatformStore::new(&pool, "");
        let created = store.create(platform_data).await.unwrap();

        assert_eq!(created.issuer, "https://test.example.com");

        // Cleanup
        let mut conn = pool.get().unwrap();
        diesel::delete(lti_platforms::table
            .filter(lti_platforms::issuer.eq("https://test.example.com")))
            .execute(&mut conn)
            .unwrap();
    }
}
```

## Common Issues and Solutions

### 1. Schema Out of Sync

**Issue:** Compile errors after running migrations

**Solution:**
```bash
# Regenerate schema
diesel migration run
# or
diesel print-schema > src/schema.rs
```

### 2. JSONB Type Errors

**Issue:** Type mismatch with JSONB columns

**Solution:**
```rust
// Use serde_json::Value
use serde_json::Value as JsonValue;

// In schema.rs, Diesel maps JSONB to Jsonb type
// In Rust, use JsonValue for the field type
```

### 3. Async/Sync Interop

**Issue:** Cannot use `await` in synchronous Diesel code

**Solution:**
```rust
// Wrap Diesel calls in spawn_blocking
use tokio::task;

async fn async_query() -> Result<T, Error> {
    let mut conn = pool.get()?;

    task::spawn_blocking(move || {
        // Diesel query here (synchronous)
        use schema::table::dsl::*;
        table.load::<Model>(&mut conn)
    })
    .await?
}
```

### 4. Connection Pool Issues

**Issue:** Too many database connections

**Solution:**
```rust
// Configure pool size
use diesel::r2d2::{self, ConnectionManager, Pool};

let manager = ConnectionManager::<PgConnection>::new(&database_url);
let pool = Pool::builder()
    .max_size(5)  // Limit pool size
    .build(manager)?;
```

### 5. Foreign Key Violations

**Issue:** Cannot delete parent row

**Solution:**
```rust
// Delete in correct order: children first
diesel::delete(lti_registrations::table
    .filter(lti_registrations::platform_id.eq(platform_id)))
    .execute(&mut conn)?;

diesel::delete(lti_platforms::table
    .filter(lti_platforms::id.eq(platform_id)))
    .execute(&mut conn)?;
```

## Diesel vs SQLx Comparison

### Query Style

**Diesel (Type-safe builder):**
```rust
lti_platforms
    .filter(issuer.eq("https://canvas.instructure.com"))
    .first::<LtiPlatform>(&mut conn)?
```

**SQLx (SQL with macros):**
```rust
sqlx::query_as!(
    LtiPlatform,
    "SELECT * FROM lti_platforms WHERE issuer = $1",
    "https://canvas.instructure.com"
)
.fetch_one(&pool).await?
```

### Migrations

**Diesel:**
- Two-way migrations (up.sql, down.sql)
- Auto-generates schema.rs
- CLI: `diesel migration run`

**SQLx:**
- One-way migrations by default
- Compile-time verification
- CLI: `sqlx migrate run`

### Async Support

**Diesel:**
- Synchronous API
- Requires async wrapper (`spawn_blocking`)

**SQLx:**
- Native async/await
- No wrapper needed

### JSONB Support

**Diesel:**
- Built-in support with `serde_json::Value`
- Type-safe with schema

**SQLx:**
- Built-in support with `Json<T>`
- Runtime conversion

## Best Practices

### 1. Use Transactions

```rust
use diesel::Connection;

conn.transaction::<_, Error, _>(|conn| {
    // Multiple operations
    diesel::insert_into(table1).values(&data1).execute(conn)?;
    diesel::insert_into(table2).values(&data2).execute(conn)?;
    Ok(())
})?;
```

### 2. Batch Operations

```rust
// Insert multiple records at once
diesel::insert_into(table)
    .values(&vec_of_new_records)
    .execute(&mut conn)?;
```

### 3. Connection Management

```rust
// Use connection pool
let pool = create_pool()?;

// Get connection only when needed
let mut conn = pool.get()?;

// Connection automatically returned to pool when dropped
```

### 4. Error Handling

```rust
use diesel::result::Error as DieselError;

match result {
    Ok(data) => Ok(data),
    Err(DieselError::NotFound) => Ok(None),  // Handle not found
    Err(e) => Err(e.into()),  // Convert other errors
}
```

## Related Documentation

- [Diesel Getting Started](https://diesel.rs/guides/getting-started)
- [Diesel Schema](https://diesel.rs/guides/schema-in-depth)
- [Migration Guide](/docs/lti-improvements/MIGRATION_GUIDE.md)
- [Implementation Summary](/docs/lti-improvements/IMPLEMENTATION_SUMMARY.md)

## License

MIT
